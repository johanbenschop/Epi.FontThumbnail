using Geta.Epi.FontThumbnail.EnumGenerator.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Threading.Tasks;

namespace Geta.Epi.FontThumbnail.EnumGenerator
{
    internal static class Program
    {
        static async Task Main(string[] args)
        {
            string sourcePath = Directory.GetParent(Directory.GetCurrentDirectory()).Parent.Parent.Parent.FullName;

            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine("Font Awesome Enum Generator");
            Console.WriteLine("{0}", sourcePath);
            string enumBasePath = $@"{sourcePath}\Geta.Epi.FontThumbnail";
            Console.WriteLine("\nOutput directory: {0}", enumBasePath);
            
            var fontAwesomeZipStream = await GithubDownloader.DownloadLatestReleaseAsync("FortAwesome", "Font-Awesome");

            using (var archive = new ZipArchive(fontAwesomeZipStream))
            {
                var metaData = archive.GetEntry("metadata/icons.json");


                foreach (var entry in archive.Entries)
                {
                    var stream = entry.Open();
                    
                }
            }

            AskForFontAwesomeDirectory:
            Console.WriteLine("\nEnter the Font Awesome directory:");
            string fontAwesomePath = @"C:\Dev\fontawesome-free-5.3.1-web"; //Console.ReadLine();
            if (!Directory.Exists(fontAwesomePath))
            {
                Console.WriteLine("\nDirectory does not exist.");
                goto AskForFontAwesomeDirectory;
            }

            string metadataPath = $@"{fontAwesomePath}\metadata\icons.json";
            if (!File.Exists(metadataPath))
            {
                Console.WriteLine("\nDirectory does not contain a metadata directory with a icons.json file.");
                goto AskForFontAwesomeDirectory;
            }

            Console.WriteLine("\nLoading metadata from: {0}", metadataPath);
            IList<MetadataIcon> metadata = LoadMetadata(metadataPath);

            // Get a list all the different styles
            IEnumerable<string> styles = metadata.SelectMany(x => x.Styles).Distinct();

            foreach (string item in styles)
            {
                string styleName = CultureInfo.CurrentCulture.TextInfo.ToTitleCase(item);
                string enumName = $"FontAwesome5{styleName}";
                string localPath = $@"{enumBasePath}\{enumName}.cs";

                Console.WriteLine("\nGenerating {0}.cs...", enumName);
                IEnumerable<MetadataIcon> icons = metadata.Where(x => x.Styles.Contains(item) && !x.Private);
                WriteEnumToFile(localPath, enumName, icons);
            }

            CopyFontFiles(fontAwesomePath, enumBasePath);

            Console.WriteLine("\nDone generating Enums. Press enter to exit.");
            Console.ReadLine();
        }

        private static void CopyFontFiles(string fontAwesomePath, string enumBasePath)
        {
            string source = $@"{fontAwesomePath}\webfonts\";
            string destination = $@"{enumBasePath}\Fonts\";

            string[] filesToCopy = Directory.GetFiles(source, "*.ttf");
            foreach (string fileToCopy in filesToCopy)
            {
                Console.WriteLine("\nCopying {0} to {1}...", fileToCopy, destination);
                File.Copy(fileToCopy, destination + Path.GetFileName(fileToCopy), true);
            }
        }

        private static IList<MetadataIcon> LoadMetadata(string path)
        {
            using (StreamReader file = File.OpenText(path))
            {
                JsonSerializer serializer = new JsonSerializer();
                serializer.Converters.Add(new FontAwesomeJsonConverter());
                return (List<MetadataIcon>)serializer.Deserialize(file, typeof(List<MetadataIcon>));
            }
        }

        private static void WriteEnumToFile(string path, string enumName, IEnumerable<MetadataIcon> icons)
        {
            string latestVersionChange = icons.SelectMany(x => x.Changes).Distinct().OrderBy(x => x).Last();

            using (StreamWriter writer = new StreamWriter(path))
            {
                writer.WriteLine("//------------------------------------------------------------------------------");
                writer.WriteLine("// <auto-generated>");
                writer.WriteLine("//     This code was generated by a tool.");
                writer.WriteLine("//");
                writer.WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if");
                writer.WriteLine("//     the code is regenerated.");
                writer.WriteLine("// </auto-generated>");
                writer.WriteLine("//------------------------------------------------------------------------------");
                writer.WriteLine();

                writer.WriteLine("namespace Geta.Epi.FontThumbnail\n{");

                writer.WriteLine("\t/// <summary>");
                writer.WriteLine($"\t/// Font Awesome. Version {latestVersionChange}.");
                writer.WriteLine("\t/// </summary>");

                writer.WriteLine($"\tpublic enum {enumName}");
                writer.WriteLine("\t{");

                foreach (MetadataIcon icon in icons)
                {
                    writer.WriteLine("\t\t/// <summary>");
                    writer.WriteLine($"\t\t/// {icon.Label.ToTitleCase()} ({icon.Name})");
                    WriteStyles(writer, icon);
                    WriteSearchTerms(writer, icon);
                    WriteChanges(writer, icon);
                    writer.WriteLine("\t\t/// </summary>");

                    string name = GetEnumSafeName(icon);
                    writer.WriteLine($"\t\t{name} = 0x{icon.Unicode},\n");
                }

                writer.WriteLine("\t}\n}");
            }
        }

        private static void WriteStyles(StreamWriter writer, MetadataIcon icon)
        {
            if (icon.Styles?.Count > 1)
            {
                writer.WriteLine($"\t\t/// <para>Styles: {string.Join(", ", icon.Styles)}</para>");
            }
        }

        private static void WriteSearchTerms(StreamWriter writer, MetadataIcon icon)
        {
            if (icon.Search?.Terms?.Count > 0)
            {
                writer.WriteLine($"\t\t/// <para>Terms: {string.Join(", ", icon.Search.Terms)}</para>");
            }
        }

        private static void WriteChanges(StreamWriter writer, MetadataIcon icon)
        {
            IOrderedEnumerable<string> changes = icon.Changes.Select(x => x.FormatSemver()).OrderBy(x => x);

            writer.Write($"\t\t/// <para>Added in {changes.First()}");
            if (changes.Count() > 1)
            {
                IEnumerable<string> otherChanges = changes.Skip(1);
                string result = string.Join(", ", otherChanges.Take(otherChanges.Count() - 1)) + (otherChanges.Count() > 1 ? " and " : string.Empty) + otherChanges.LastOrDefault();
                writer.Write($", updated in {result}");
            }
            writer.Write(".</para>\n");
        }

        private static string GetEnumSafeName(MetadataIcon icon)
        {
            string name = icon.Name.Replace('-', ' ');
            name = name.ToTitleCase();
            name = name.Replace(" ", string.Empty);
            if (char.IsDigit(name[0]))
            {
                name = "_" + name;
            }

            // Verify reverse conversion
            string reverse = name.ToDashCase().Replace("_", string.Empty);
            if (!icon.Name.Equals(reverse))
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"{icon.Name}\t!=\t{reverse}\t{name}");
                Console.ForegroundColor = ConsoleColor.White;
            }

            return name;
        }

        public static string ToDashCase(this string input)
        {
            return string.Concat(input.Select((c, i) => i > 0 && char.IsUpper(c) && (!char.IsDigit(input[i - 1]) || !char.IsDigit(input[i - 2 > 0 ? i - 2 : 0])) ? "-" + c : c.ToString())).ToLower();
        }
    }
}
